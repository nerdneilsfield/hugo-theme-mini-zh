<footer id="footer">
    {{ if .Site.Params.social }}
        {{ partial "social.html" . }}
    {{ end }}

    <div class="copyright">
    {{ with .Site.Params.copyright }}
        {{ . | markdownify }}
    {{ else }}
       © Copyright 
       {{ now.Format "2006"}} 
       <span class="split">
        {{ partial "svgs/heart.svg" (dict "fill" "#bbbbbb" "width" 15 "height" 15 ) }}
       </span>
       {{ .Site.Params.Author }}
    {{ end }}
    </div>

    {{ if ne .Site.Params.showPowerBy false }}
      <div class="powerby">
        {{ i18n "poweredBy" | safeHTML }}
      </div>
    {{ end }}
</footer>

{{ if .Page.Store.Get "hasMermaid" }}
<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<script>
(function(){
  if(!window.mermaid) return;

  const normalizeTargets = () => {
    const targets = new Set();

    document.querySelectorAll('pre code.language-mermaid').forEach(code => {
      const graph = code.textContent.trim();
      if (!graph) return;
      const pre = code.parentElement;
      if (!pre) return;
      pre.dataset.mermaidGraph = graph;
      let host = pre.nextElementSibling;
      while (host && host.nodeType === Node.TEXT_NODE) host = host.nextSibling;
      if (!host || !host.classList || !host.classList.contains('mermaid-diagram')) {
        host = document.createElement('div');
        host.className = 'mermaid mermaid-diagram';
        pre.insertAdjacentElement('afterend', host);
      }
      host.dataset.graph = graph;
      pre.style.display = 'none';
      targets.add(host);
    });

    document.querySelectorAll('.mermaid').forEach(el => {
      if (!el.dataset.graph) el.dataset.graph = el.textContent.trim();
      targets.add(el);
    });

    return Array.from(targets);
  };

  const render = (mode) => {
    const theme = mode === 'dark' ? 'dark' : 'default';
    const hosts = normalizeTargets();
    if (!hosts.length) return;
    mermaid.initialize({ startOnLoad: false, theme });
    hosts.forEach(host => {
      const graph = host.dataset.graph;
      if (!graph) return;
      host.textContent = graph;
      host.removeAttribute('data-processed');
    });
    requestAnimationFrame(() => {
      if (typeof mermaid.init === 'function') {
        hosts.forEach(host => mermaid.init(undefined, host));
      }
    });
  };

  const getMode = () => {
    const doc = document.documentElement;
    if (doc.classList.contains('force-dark')) return 'dark';
    if (doc.classList.contains('force-light')) return 'light';
    const prefers = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
    return prefers ? 'dark' : 'light';
  };

  render(getMode());
  document.addEventListener('qiqi-themechange', (event) => {
    render(event.detail.effective);
  });
})();
</script>
{{ end }}

{{ if .Page.Store.Get "hasMarkmap" }}
<style>
  .markmap { position: relative; }
  .markmap > svg { width: 100%; height: 360px; }
  @media (min-width: 768px) { .markmap > svg { height: 480px; } }
  @media (min-width: 1200px) { .markmap > svg { height: 560px; } }
  .mm-toolbar { font-size: 13px; }
  .mm-toolbar .mm-toolbar-item { padding: 2px; }
</style>
<script>
  window.markmap = window.markmap || {};
  window.markmap.autoLoader = Object.assign({ toolbar: true }, window.markmap.autoLoader || {});
</script>
<script src="https://cdn.jsdelivr.net/npm/markmap-autoloader"></script>
<script>
(function(){
  const isReady = () => !!(window.markmap && window.markmap.Markmap && (window.markmap.autoLoader || window.markmap.Transformer));
  if (!isReady()) return;

  const transformer = (window.markmap.autoLoader && window.markmap.autoLoader.transformer)
    ? window.markmap.autoLoader.transformer
    : new window.markmap.Transformer();

  const collectHosts = () => {
    const hosts = new Set();

    document.querySelectorAll('pre code.language-markmap').forEach(code => {
      const markdown = code.textContent.trim();
      if (!markdown) return;
      const pre = code.parentElement;
      if (!pre) return;
      pre.dataset.markmapMarkdown = markdown;
      let host = pre.nextElementSibling;
      while (host && host.nodeType === Node.TEXT_NODE) host = host.nextSibling;
      if (!host || !host.classList || !host.classList.contains('markmap-host')) {
        if (host && host.classList && host.classList.contains('markmap')) {
          host.classList.add('markmap-host');
        } else {
          host = document.createElement('div');
          host.className = 'markmap markmap-host';
          pre.insertAdjacentElement('afterend', host);
        }
      }
      host.dataset.markmap = markdown;
      pre.style.display = 'none';
      hosts.add(host);
    });

    document.querySelectorAll('.markmap').forEach(el => {
      if (!el.dataset.markmap) {
        const template = el.querySelector('script[type="text/markmap"], script[type="text/template"]');
        if (template) {
          el.dataset.markmap = template.textContent.trim();
        } else if (el.textContent.trim() && !el.querySelector('svg')) {
          el.dataset.markmap = el.textContent.trim();
        }
      }
      if (el.dataset.markmap) hosts.add(el);
    });

    return Array.from(hosts);
  };

  const render = () => {
    if (!isReady()) return;
    const { Markmap } = window.markmap;
    const hosts = collectHosts();
    hosts.forEach(host => {
      const markdown = host.dataset.markmap;
      if (!markdown) return;
      const { root, features } = transformer.transform(markdown);
      host.innerHTML = '';
      const instance = Markmap.create(host, {}, root);
      if (features && window.markmap.autoLoader && typeof window.markmap.autoLoader.setToolbar === 'function') {
        window.markmap.autoLoader.setToolbar(instance, features);
      }
    });
  };

  render();
  document.addEventListener('qiqi-themechange', render);
})();
</script>
{{ end }}

{{ range .Site.Params.customJS }}
    {{ if ( or ( hasPrefix . "http://" ) ( hasPrefix . "https://" ) ) }}
        <!-- remote js -->
        <script src="{{ . }}"></script>
    {{ else }}
        <!-- local js -->
        <script src="{{ $.Site.BaseURL }}{{ . }}"></script>
    {{ end }}
{{ end }}

<script>
// TOC scrollspy + 抽屉按钮：同时支持抽屉内与旧版位置
(function(){
  const toc = document.querySelector('#toc-drawer #TableOfContents') || document.querySelector('.toc #TableOfContents');

  if (toc) {
    // 默认只显示到 h3：隐藏第三层以下的嵌套 ul（从第四层起）
    const collapseDeeper = () => {
      const uls = toc.querySelectorAll('ul ul ul ul');
      uls.forEach(ul => ul.style.display = 'none');
    };
    collapseDeeper();

    const headings = Array.from(document.querySelectorAll('.content h1, .content h2, .content h3, .content h4, .content h5'));
    const links = Array.from(toc.querySelectorAll('a'));
    const idMap = new Map();
    links.forEach(a => { idMap.set(a.getAttribute('href'), a); });

    let activeHref = null;
    const onScroll = () => {
      if (headings.length === 0 || links.length === 0) return;
      let current = null;
      const fromTop = window.scrollY + 120; // offset below header
      for (const h of headings) {
        if (h.offsetTop <= fromTop) current = h; else break;
      }
      if (!current || !current.id) return;
      const href = '#' + current.id;
      if (href === activeHref) return;
      activeHref = href;
      links.forEach(a => a.classList.remove('is-active'));
      collapseDeeper();
      const activeLink = idMap.get(href);
      if (activeLink) {
        activeLink.classList.add('is-active');
        let node = activeLink.parentElement;
        while (node && node !== toc) {
          if (node.tagName === 'UL') node.style.display = '';
          node = node.parentElement;
        }
        const nextUl = activeLink.nextElementSibling;
        if (nextUl && nextUl.tagName === 'UL') nextUl.style.display = '';
        activeLink.scrollIntoView({block: 'nearest'});
      }
    };
    document.addEventListener('scroll', onScroll, { passive: true });
    onScroll();
  }

  // 抽屉按钮控制（即使没有 toc 也不报错）
  const toggleBtn = document.getElementById('btn-toc');
  const drawer = document.getElementById('toc-drawer');
  const backdrop = document.getElementById('toc-backdrop');
  const closeBtn = drawer ? drawer.querySelector('.toc-close') : null;
  const isOpen = () => drawer && !drawer.hidden;
  const setOpen = (open) => {
    if(!drawer || !backdrop || !toggleBtn) return;
    drawer.hidden = !open;
    backdrop.hidden = !open;
    drawer.setAttribute('aria-hidden', String(!open));
    toggleBtn.setAttribute('aria-expanded', String(open));
    if(open){
      document.body.dataset.tocLocked = document.body.dataset.tocLocked || document.body.style.overflow || '';
      document.body.style.overflow = 'hidden';
    }else{
      if('tocLocked' in document.body.dataset){
        document.body.style.overflow = document.body.dataset.tocLocked;
        delete document.body.dataset.tocLocked;
      }else{
        document.body.style.removeProperty('overflow');
      }
    }
  };
  drawer && drawer.setAttribute('aria-hidden', String(drawer.hidden));
  toggleBtn && toggleBtn.addEventListener('click', () => setOpen(!isOpen()));
  closeBtn && closeBtn.addEventListener('click', () => setOpen(false));
  backdrop && backdrop.addEventListener('click', () => setOpen(false));
  document.addEventListener('keydown', (event) => {
    if(event.key === 'Escape') setOpen(false);
  });
})();
</script>

<script>
// Theme toggle
(function(){
  var KEY='qiqi.theme';
  var mql = window.matchMedia ? window.matchMedia('(prefers-color-scheme: dark)') : null;
  var btn=document.getElementById('btn-theme');
  var currentMode=null;
  function get(){ try{return localStorage.getItem(KEY)||'auto';}catch(e){return 'auto';} }
  function set(v){ try{localStorage.setItem(KEY,v);}catch(e){} }
  function apply(v){
    var d=document.documentElement;
    var b=document.body;
    var prefersDark = mql ? mql.matches : false;
    var effective = v;
    if(v==='auto') effective = prefersDark ? 'dark' : 'light';
    d.classList.remove('force-dark','force-light');
    b && b.classList.remove('force-dark','force-light');
    d.removeAttribute('theme');
    if(effective==='dark'){
      d.classList.add('force-dark');
      b && b.classList.add('force-dark');
      d.setAttribute('theme','dark-mode');
    }else if(effective==='light'){
      d.classList.add('force-light');
      b && b.classList.add('force-light');
    }
    if(btn){
      var label;
      if(v==='auto'){
        label = prefersDark ? '🌓 自动·深色' : '🌓 自动·浅色';
      }else if(v==='dark'){
        label = '🌙 深色';
      }else{
        label = '☀️ 浅色';
      }
      btn.textContent = label;
      btn.setAttribute('aria-label', label.replace(/^\S+\s*/, ''));
    }
    if(currentMode !== effective){
      currentMode = effective;
      document.dispatchEvent(new CustomEvent('qiqi-themechange', { detail: { value: v, effective: effective } }));
    }
  }
  function cycle(){ var v=get(); v = (v==='auto')?'dark':(v==='dark'?'light':'auto'); set(v); apply(v); }
  apply(get());
  mql && mql.addEventListener && mql.addEventListener('change', function(){ if(get()==='auto') apply('auto'); });
  btn && btn.addEventListener('click', cycle);
  document.addEventListener('keydown', function(e){
    if(e.target && /input|textarea|select/i.test(e.target.tagName)) return;
    if(e.key && e.key.toLowerCase()==='d') cycle();
  });
})();
</script>
